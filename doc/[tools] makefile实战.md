### 基础
#### 1. Makefile基础组成
   ~~~
     target: prerequisites
         command
         ...
   ~~~
说明:
- target也就是一个目标文件，可以是object file，也可以是执行文件，还可以是一个标签（label）（“伪目标”，“命令”）
- prerequisites就是，要生成那个target所需要的文件或是目标
- command也就是make需要执行的命令（任意的Shell命令）。这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则，也就是Makefile中最核心的内容
![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/00843016-adfc-41dd-be80-01f1deff415b)


#### 2. 原理
- make并不管命令是怎么工作的，他只管执行所定义的命令。
- make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令
- 对于make来说，后面跟的可以是Makefile中声明的“命令”，也可以是路径下某个同名文件，make本身不做区分(重点)
- 当在Makefile中用.PHONY指定后，就限定某名称只作为命令使用，而不会受到路径下同名文件的影响（若同名，target为文件的优先级更高）
#### 3. 常用符号的含义
- 井号 # 为注释符
- 反斜杠 \ 是换行符的意思，这样比较便于Makefile的易读
- 如果make执行的命令前面加了@字符，则不显示命令本身而只显示它的结果
- 通常make执行的命令如果出错就立刻终止，不再执行后续命令，但如果命令前面加了-号，即使这条命令出错，make也会继续执行后续命令
- 通常rm命令和mkdir命令前面要加-号，因为rm要删除的文件可能不存在，mkdir要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。
- 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头（出错的话gvim的高亮会提示你）
#### 4. Makefile依赖关系
- make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错
- 如果target有同名文件，那么需要查看它的依赖关系，依赖关系比它日期新或没有依赖关系，便会执行它；否则不会执行
- 如果用.PHONY定义了，那么即使有同名文件，也一定会执行该命令
#### 5. Makefile中的变量
= 普通的变量赋值，后面会覆盖前面 
:= 只把当前时刻的值赋给变量（不能使用后面的变量，只能使用前面已定义好了的变量）
?= 如果之前没定义过才进行赋值
+= 给变量追加值
#### 6. Makefile常用预定义变量
$*   不包含扩展名的目标文件名称
$+   所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件
$<   第一个依赖文件的名称
$?   所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚
$@ 目标的完整名称
$^   所有的依赖文件，以空格分开，不包含重复的依赖文件
#### 7. 合理运用touch加速编译时间
1. 在一条指令执行完后，加上@touch $@，可以生成一个与该命令同名的文件；
- 结合上文内容，我们可理解下述做法的好处:这种做法常见于编译TB中不太会改变内容，例如第三方的VIP，或项目后期稳定后的DUT
2. 命令的依赖关系是指，一条命令依赖于冒号后和它同一行后面的内容
3. 如果删掉路径下的tmp.h，紧接着手动touch tmp.h，重新生成一份该文件，再执行make elab，你会发现尽管当前存在compile_m1这个文件，但同名的命令还是被执行了,编译过程中会记录下这次用到的文件的“信息”，当删除了tmp.h再重新创建一个同名的文件（即使这个文件中什么都没有），系统还是会认为上一次编译时候看到的tmp.h已经不见了
4. 被依赖的文件不只可以是这种空的touch出来的文件，还可以是任何我们指定的DUT或TB的文件，只要这些文件有变动，那么依赖关系就有变动
![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/90902b88-6fb8-471c-8c3c-9388feca78fc)

![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/94d6b75e-8305-4f32-b41c-7ce7640e2282)
~~~
举例：下图中elab命令依赖于compile_m1和compile_m2；第一次执行make elab
后，会先执行compile_m1和compile_m2命令，
再执行第30行的内容；当第二次执行make elab时，
则不会执行compile_m1命令的内容，
从而节省了时间；若还想执行compile_vip，
删掉路径下该同名文件即可
~~~

#### 8. 译中“域”的概念
- 一个编译命令后的所有文件属于一个“域”
- 不同编译命令后面的文件属于不同“域”，互相不可见，需要采用类似import pkg的方式看到对方
- 一个文件中所有include的文件属于一个“域”



### 经验

### 传送门
