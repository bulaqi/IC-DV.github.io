### 1. 基础知识
#### 1. 常用伪随机的产生
1. 概率分步函数
   - $random,
   - $dist_uniform,
   - $dist_normal,
   - $dist_exponential,
   - $dist_poisson
2. 对象随机方法
   - 所有SV类中都会默认存在的内置虚函数（原型是virtual function int randomize()），但是它不能被覆盖（overridden）
   - 使用object.randomize() 来对对象进行随机化的时候，注意它只会随机化类中有rand关键词修饰的成员变量，并且在成功随机化之后会返回1，失败则返回0
   - 类中还有randomize的两个回调函数pre_randomize()和post_randomize()
   - 补充说明: object.randomize()还是只能随机化类的成员变量，不能随机化局部变量
   - Std lib下的std::randomize()的适用性比object.randomize()要好，不过它不能自动随机对象中的rand成员变量，也没有pre和post函数可以调用
3. 随机系统函数
   - $urandom()
   - $urandom_range()
4.  数组的shuffle()
   - 使得数组的元素随机排序，某些场景下可以快速获取不重复序列，
   - 但是不推荐使用，此方法太过于占用内存资源
     
#### 2. 随机稳定性分析
1. 随机的稳定性
   在SV中，不同线程（thread）或对象（object）在随机化时使用的随机数产生器（RNG）是相互独立的。相同线程或相同对象在相同随机种子的情况下，每一次仿真中产生的随机数序列是一样的
2. 概率分步函数的
   - $random()如果不带参数设置种子，那么程序每次运行都会获得相同的随机序列，与线程、其他随机无关，每一次得到的随机序列只跟调用的顺序相关，
   - 所以，最好不要用$random()来获取随机数，非要用的话每次都指定不同的随机种子$random(seed)。
3. 线程随机稳定性
   - 同一个线程的随机只受本线程的种子设置、调用顺序影响，不受其他线程的随机影响，即线程间的随机是互不干扰的，**对象的随机也不会干扰线程的随机**；
   - 但是在同一个线程中，$urandom()、$urandom_range()、$std::randomize()、randcase、randsequence、shuffle()是使用同一个随机数发生器的，所以同一线程中它们的调用会相互影响。
4. 对象的随机稳定性
   - 对象的randomize()的随机结果只和对象的种子相关，而和线程的随机、其他对象的随机无关。
#### 3. 影响随机结果的因素
1. 种子变化
   - 运行时种子变化（运行时指定或者手动指定种子）后，会影响线程改变点后的所有相关随机。
2. 同一个线程中调用顺序变化
  - 在同一个线程的某个随机调用前增加或者减少urandom()、$urandom_range()、$std::randomize()、randcase、randsequence、shuffle()这些使用同一个随机数发生器的随机，将会使得随机结果发生改变
  - 在一个测试程序中如果希望尽可能的减少对程序的改变，增加的随机最好加在线程的后面。
3. 其他
  - 改变了std::randomize()，randsequence、randcase、$urandom_range()的条目数量、权重、范围都会改变随机结果。

#### 4. 专用名词解释
- 随机数发生器（RNG）
  
### 2. 传送门
1. [SystemVerilog | 暗藏玄机的随机化方法](https://zhuanlan.zhihu.com/p/404704966)
2. [SV的随机稳定性](https://zhuanlan.zhihu.com/p/256217124)

