1. SSD 读什么比写 快? 
   - 读：读取数据时，数据直接从 NAND Flash 单元读出，这是一个相对简单的过程
   - 写：写入数据到 NAND Flash 中时，如果目标单元已经包含数据，则需要先擦除旧数据，然后才能写入新数据。擦除操作是一个耗时较长的过程，因为它涉及到将整个块的数据置零，而不是只改变需要更新的部分
   - 所以：读比写快
2. SSD 连续读写和 随机读写的 过程对比?
   - 连续读写
       - 连续读取
         - 过程：
           - 连续读取过程中，数据是从连续的物理位置读取的。
           - 据按顺序加载到缓存中，然后传输给请求者。
           - 种类型的读取通常利用了缓存和预读取机制，以提高效率。
         - 特点：
           - 连续读取通常具有较高的吞吐量。
           - 因为数据是顺序加载的，所以可以最大化利用 SSD 的带宽。
           - 连续读取对于文件系统中的大文件特别有效。
       - 连续写入
         - 过程：
           - 连续写入同样涉及将数据写入连续的物理位置。
           - 写入操作可以利用 NAND Flash 的特性，即在没有现有数据的情况下直接写入。
           - 如果目标位置已有数据，则需要先擦除再写入。
         - 特点：
            - 连续写入通常比随机写入更快。
            - 它可以更有效地利用 SSD 的写入性能。
            - 连续写入有助于减少磨损均衡和垃圾回收的需求。
   - 随机读写
       - 随机读取
         - 过程：
           - 随机读取是指从不连续的物理位置读取数据。
           - 每次读取操作都需要寻址不同的位置，这可能导致更多的延迟。
           - 控制器通常会使用缓存和映射表来加快这一过程。
         - 特点：
           - 随机读取通常具有较低的延迟。
           - 由于数据不是连续的，寻址和读取每个块可能需要更多的时间。
           - 随机读取常见于操作系统和数据库等场景。
       - 随机写入
         - 过程：
           - 随机写入是指向不连续的物理位置写入数据。
           - 由于 NAND Flash 的特性，写入之前可能需要先擦除旧数据。
           - 这种类型的写入可能会触发磨损均衡和垃圾回收操作。
         - 特点：
           - 随机写入通常比连续写入慢得多。
           - 它可能导致更多的磨损均衡和垃圾回收活动，从而降低整体性能。
           - 随机写入常见于应用程序频繁修改小块数据的情况。
   - 总结:
       - 连续操作通常在处理大型文件或大量连续数据时表现更好，因为它们能够最大化利用 SSD 的带宽和 I/O 吞吐量。
       - 随机操作更适合处理数据库查询、多任务处理或需要频繁访问不同文件的小型文件系统操作，但由于寻址和擦除/写入过程，它们的性能通常较低。
  
3. IsSerial
   连续性标志。该位为1表示下一次输出的相同的Controller ID和SQID的IOSQE一定与当前输出的在LBA上连续（Namespace和读/写命令类型也相同），即：


需要说明的是，“下一次输出的相同的Controller ID和SQID的IOSQE”并不意味着该IOSQE在下一个IOSQE被输出，也就是，在当前IOSQE输出完成后，可以输出若干属于其他Controller ID或其他SQID的IOSQE，然后再输出与这个IOSQE拥有相同的Controller ID和SQID的IOSQE。

该位为0表示下一次输出的相同的Controller ID和SQID的IOSQE不一定与当前输出的在LBA上连续，也就是有可能连续也有可能不连续，AEM无法提前获取该信息。


连续性标志。该位为1表示下一次输出的相同的Controller ID和SQID的IOSQE一定与当前输出的在LBA上连续，即：
	当前的Namespace与下一次的相同；
	当前的Start LBA + NLB与下一次的Start LBA相同。
	当前的IOSQE和下一次会被发送给同一个RAC。

需要说明的是，“下一次输出的相同的Controller ID和SQID的IOSQE”并不意味着该IOSQE在下一个IOSQE被输出，也就是，在当前IOSQE输出完成后，可以输出若干属于其他Controller ID或其他SQID的IOSQE，然后再输出与这个IOSQE拥有相同的Controller ID和SQID的IOSQE。
该位为0表示下一次输出的相同的Controller ID和SQID的IOSQE不一定与当前输出的在LBA上连续，也就是有可能连续也有可能不连续，AEM无法提前获取该信息。

	当前输出的IOSQE不是该SQ的最后一个；
	当前输出的IOSQE与下一个IOSQE的命令相同；
	当前输出的IOSQE与下一个IOSQE的Namespace字段相同；
	当前输出的IOSQE的结束地址+1等于下一个IOSQE的SLBA；
	当前输出的IOSQE与下一个IOSQE将被分发至同一个RAC



4. Linked-Buffer
用来将一片连续的Memory，动态的分配给所有的SQ
使每个SQ的SQE，即使在该Memory的物理地址上不连续，但逻辑上是可以连续进行读取访问的
主要作用：
该Linked-Buffer主要作用是将DMA获取的SQE按SQ进行保存
linked-Buffer在实现上可以分为两部分
