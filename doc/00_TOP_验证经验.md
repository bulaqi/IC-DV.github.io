### 1. 基础知识
#### 1. 验证平台分享
1. 组件接口清晰
2. 组件分工明确
3. 事务级建模
4. 面向对象
5. 对于域段或其它类似操作访问，不要用变量的按索引切片或者位宽切片，以及绝对寻址的操作。
6. 先写档，画框图


#### 2. 随机约束
1. 尽量不要在约束中出现除法与取模操作，可以用切片操作和移位运算代替
2. 约束内是可以用系统函数的
3. 约束尽量简单，复杂运算在post_randomize中完成
4. 也可通过外部传参控制约束行为
5. 约束内的对变量的多维嵌套约束操作是不支持的
6. Soft可以方便非常规用例的实现
7. 约束求解会按照有符号数处理，范围约束要注意

#### 3. 覆盖率
1. 覆盖组基于事务采样，特殊形况除外
2. 采样条件一定要注意，不合适地采样条件会很大地影响仿真效率
3. 覆盖组的采样函数是可以重写并传参的，可以注意使用（可参考ones分享或者SV标准）
4. 对于多bit或者数据采样，是可以简化定义的。当然也可以使用宏。（可参考ones分享）
5. 定义仓以及做cross时，一定要注意仓的个数
6. Cross时，是可以控制自动产生的仓的最大个数的（旧SV标准）
7. 基于时钟的采样，要额外注意采样条件。
8. 采样数据时，尽量不要出现算数运算，尤其是除法与取模操作
9. 可以多用iff
10. Cross是可以cross的

#### 3. 验证复用性
1. 清晰的平台框架
2. 明确的组件接口
3. 多使用组合，而不是继承
4. 减少DUT层次引用，剥离平台的硬件相关部分
5. 减少TB层次引用（最好不要，除非顶层），代替以其它形式（event等等）
6. 开始阶段先做好平台规划，先写文档，画框图
7. 类、函数的实现，可多用enum、struct、对象进行传参，可考虑参数化的类（模板类）
8. 大断重复代码，可考虑用函数或者宏代替
9. 可将较为常用且共用的方法、数据加一级封装
10. 组件内数据定义尽量保持统一
11. 考虑通用复位接口。
    - 分享一个想法，将组件内的所有成员变量实现在另一个对象内，通过对象句柄索引对应成员变量，这样部分组件的reset处理能够稍微简洁一点（不用每次大段地添加清理逻辑）。




#### 4. 仿真效率
1. 不要出现大深度数组
2. 尽量不要出现数组的克隆，传参可考虑使用ref
3. 尽量不要在new里new
4. 尽量减少循环操作及循环深度
5. 变量生命周期的考量
6. 不要滥用config_db
7. 不要随便super.builder_phase
8. 循环等待语句尽量使用iff，而不是在时钟沿始终执行，或者# number等
9. 尽量避免嵌套循环线程
10. 可以考虑事件触发来代替polling
11. 尽量减少randomize的次数，能一次的不要多次
12. 保持数据敏感，产生、保存数据时可根据数据特征选择性保存。（如64bit 4KB对齐的地址，可以不用保存. 低位地址等。）
13. 不要滥用虚函数，尤其是在循环内，每次虚函数调用都是次查表操作

### 2. 经验总结
#### 1. 验证策略
1. 模型欠缺
- 开发DPI-C、SC接口准备可能的参考模型
2. 验证平台与架构模型分工合作，完成检查。密切合作，加速迭代。
- 方案梳理 
- 与架构、设计进行紧密的方案讨论，不放过任何疑点。
3. 方案变动
- 高内聚低耦合思想搭建验证平台，减少各组件、各对象的耦合度，以应对改动带来的冲击。
- 平台多采用类，枚举，结构体，宏等数据定义与传递，提高可读性与可修改性。
- 加紧对齐方案，降低变动风险。
4. 引擎实现
- 密切关注各引擎实现，多余各owner对齐，尽快分析、拆解、理解各引擎在各场景下的实现。减少理解偏差。
5. 功能琐碎
- 罗列检查点，一一比对是否检查
- 使用通用检查
6. 涉及面广
- 通用代码开发
- 通览文档，讨论对齐
7. 与其它引擎关系非常紧密 
- 通览文档，讨论对齐

#### 2. 执行的过程策略
1. 灰盒验证：
整体输入输出当作黑盒，内部关键访问路径及控制路径白盒处理。
2. VO制定：
由于测试因子琐碎繁多，并未针对每个点进行枚举，在尽快发现问题的前提下，合并同类场景，以尽量减少测试用例数量。
3. Coverage定义：
- 基于有效传输采样
- 基于平台传输类定义
- cross所有定义的激励、配置，去除未定义的非法场景
4. 验证平台：
- 通用检查器
- 通用复位处理
- Cross 验证、架构、固件三方模型进行检查（未完全实现）
5. 检查方法：
平台检查与模型检查共同工作。
6. 性能验证
- 初期进行性能验证平台规划，插入延时传参或延时定义类
- 初仿观测RTL结果是否符合预期
- 后期通过传参添加用例进行不同场景、不同延时下性能仿真
- 性能测试结果计算在平台或用例、脚本中实现
7. 资源池Pool管理验证
- 黑盒验证
- Pool资源定义并没有附带校验信息
- 遍历验证+随机验证
- 重复性检查
- 合法性检查（是否初始化过该资源）
- 最终状态检查（各代理及Pool状态，Pool内部memory信息）
8. 分流表验证
遍历验证，检查
9.  异常验证
- 独立检查
- 复用激励
10.  Trace验证
- 连线性检查与功能检查并行
- 连线检查各模块顶层输入输出
- 检查DUT输出与平台输出的一致性（数据正确，顺序正确，地址正确）
11.  Debug验证
- 连线性检查与功能检查并行
- 连线检查各模块Debug信号与总线寄存器实体的正确性
- 检查各Debug相关及状态相关寄存器的正确性


#### 3. 敏捷开发
1. 架构、设计、验证、软件并行开发
2. 对每个重要的RTL模块做对应Monitor、Reference与Checker，并集成至顶层平台。
3. 将关键计算模块抽出做形式验证。
4. 设计按照功能通路和模块功能划分，分类分步进行。
5. 验证按照整体功能开发测试用例，进行初期通路功能验证与部分模块调试。
6. 验证平台检查模型开发同步进行。


### 3. 传送门
1. [验证经验总结.xlsx](https://github.com/bulaqi/IC-DV.github.io/files/13710375/default.xlsx)
