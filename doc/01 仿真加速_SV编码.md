### 1. 基础知识
#### 1. 1.频繁的函数/任务调用会增加开销
1. 比如：用foreach遍历方式计数（foreach有内置函数），不如单独的计数器！如下代码：
2. 慢 vs 快
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/f56405bf-7472-4f61-a44a-b136cbd83d38)
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/75f86fa5-ad0a-4c4e-8d4c-a1180f234b76)
3. 总结
   - 对于简单调用，编译器可以将函数/任务内联以避免堆栈帧操作，但复杂调用因为编译器性能考虑原因通常不会内联，每个函数/任务都将数据引用或完整的数据副本推送到调用堆栈，并处理任何指定的返回。如此就会增加仿真时间了。如果这个函数/任务本身又被循环掉用，时间就会浪费更多！
   - 上面的反例代码，通过foreach遍历来统计mad_q中的元素数，每次都需要掉用一次内部的内置函数，将会慢于一个独立的计数器！

#### 2.计算表达式、引用请“逃出”循环
1. 循环条件中不要带计算，每次循环都会计算一次
2. eg ,慢 vs 快
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/194e2a94-d2c2-44df-bbcf-f63c01542934)
3. 和循环因子无关的计算应在循环外计算好
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/f1078622-6073-42aa-a20e-5ebb2efce041)
4. 引用不要和循环沾边
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/5b94efd4-a977-4f88-a49c-61d19e569982)
5. 在硬件世界中，可以预先计算分层引用，因为这些引用在运行时是静态的。
   - 在systemverilog testbench中，引用通常是同时遍历类实例层次结构和动态类型，所有这些都可以在仿真运行期间更改。
   - 因此，模拟器必须遍历所有引用才能获得数据，这显然会降低速度。

#### 3.对于条件的相关编码长点儿心吧
##### 1.  简单的条件短路 
1. 例如：if（最高频率的条件 || 次高频率的条件 || 最低频率的条件），把最高频率的写在最前面。
2.  eg
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/b73086f2-7d87-4670-af19-225313863af1)
##### 2. 能条件成立后才进行计算的，就不要着急放到前面算。
1. 比如下面这个例子，data的计算是调用了randomize()这个函数，但是用这个值是在一个If(live==TRUE)条件成立之后才用的！
2. 假如条件没成立，那就是没用上，没用上前面是不白算了？自然就浪费资源了！
3. eg
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/e853823f-01eb-454e-a83c-24437c48479d)
##### 3. UVM平台中妙用uvm_report_enabled()函数作为条件来优
1. 如果打印详细级别设置为UVM_DEBUG或高于UVM_DEBUG，则触发消息打印。
2. 如下例，如果打印详细级别设置为UVM_DEBUG或高于UVM_DEBUG，则触发消息打印。
3. eg
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/c0e7b2d9-91c7-47be-8265-4ec9c22fad84)
##### 4. 再来一个UVM平台中玩好条件的案例，monitor或者driver进行port传递时，以port的size()为条件，减少不必要的打数据包的次数。



#### 4.连接处logic的语义显式声明wire，可以折叠为同一对象，加快仿真速度（RTL or TB）
1.  SystemVerilog中的logic类型，它可以有wire线存储或var变量存储，如果没有显式声明，则存储类型由仿真器根据上下文确定。
  - 别小看这个类型，对仿真差别很大哦，如果是wire型，仿真器可以折叠为同一对象以获得更高的仿真速度，但是变量却不能！
  -  因为logic类型的语义除了在input、inout之外的所有情况下全都默认为变量存储！所以你的代码有时候可能仿真正确，但不知道为啥比想象中的慢！
  - 如上例子中A2.y、A2.X1.y和A2.X1.T1.y是不同的，粗体wire声明允许将它们折叠为单个对象。（当然上例子中input本身默认为wire类型不需要显式声明，但是全部显式声明更加清楚，这个代码风格更好）
2. eg
   

#### 5.在“向量”上直接操作比操作bit更快
1. 顺便一提，上面的反例中，除了位操作，而且效率低下的示例使用了一个generate语句，它创建了一个静态层次结构。这样的跨层次结构的问题，仿真器会进行优化，但是对于复杂的问题，往往不能做到很好的优化，会变成隐藏的性能问题。
2.  如上例32bit的a_t、c_t，可以看作32个1bit的变量组成的“向量”。对于这个“向量”直接操作会快于对其32个1bit循环操作。   
3. eg
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/482a1fe1-239c-4c7e-b1e3-0e2089e6d4d5)

#### 6.尽量用ref，少传递复杂数据结构
- ref会直接对目标方法的内存进行操作，这样便节省了资源，尤其是对于很多复杂数据结构例如具有数百个字段的结构体、或具有数百个元素的队列、动态数组、联合数组等。
- 其实，很多时候函数只需要拥有读取大型数据对象的访问权限即可，根本不会写入它。

#### 7.动态数据结构，不要滥用、想清楚再用
1. 尽可能使用静态数组而不是动态数组。即使数组长度有少量变化，最好指定静态数组稍大一些，而不是承担动态数组的开销（内存占用空间和垃圾收集时间）。
  - eg 比如可能有2--10个int型的元素，直接定义和使用“int A[10];”，或者更大点“int A[12];”来存储元素，而不是直接定义使用动态数组“int A[ ];”来动态分配空间。
2. 除此之外，动态数组和队列有各自适合的场景，他们都可以完成对方的功能，但是不要随意混用，否则都会有不好的性能。
  - 动态数组最适合查找，随机插入/删除操作，队列最适合自动调整大小的前后操作，仿真器具有不同的内部表示来优化他们各自的操作，所以尽量让他们去合适自己的“岗位”。


#### 8.能用单个对象，不要多new
1. 低效的内存可能导致严重的cache miss，堆管理开销和垃圾收集开销，这些都可能难以通过分析发现，所以养成好的代码习惯，例如尽量少new不必要的对象、不是必需情况下尽量少深拷贝动态对象。
2. ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/4f7149f4-c1b3-4cb9-8db4-cd519db2d94d)


#### 9.可以考虑静态类代替动态类
接着上一条，如果同一组类反复被分配内存和释放内存，仿真器通过内存管理反复循环，降低了仿真时间，而如果是静态定义的类，仿真的整体内存占用保持一致，从而执行速度会变快！

#### 10.简单异构数据结构能用结构体就不要用类
- 很多人常常有种想法认为class是基于面向对象引入的更“高级”的封装方式，结构体好像更“low”一点，其实不然！单独的类将需要堆管理并可能涉及垃圾收集，简单的struct（结构体）不会，所以更快。
- 简单异构数据结构能用结构体就不要用类了吧。
  
#### 11.接口中的“重”功能放在接口中而不是类中
1. 将接口“重”的功能放入接口而不是类中也更具仿真效率。
  - 首先，因为功能与接口本身相关联，可重用性更好。
  - 其次，在接口上操作的类包含与接口相关联的基本操作使接口的任何未来用户都可以复制此基本代码，但是通过virtual接口无法有效地引用它们。
2. eg
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/61219708-3cd8-45e5-944e-a3f9cd55ef3d)


#### 12.减少动态task或者function的唤醒
- systemVerilog仿真器是由事件驱动的，它们在给定时间点运行的事件越多，运行速度越慢。
- SystemVerilog中最常见的进程应该就是带有敏感信号（如clk）的always块来，正因如此常见，这个静态进程在所有仿真器中都进行了高度优化，
- 但是，动态task或者function（如DPI（或任何外部）功能，虚拟类任务/功能和虚拟接口任务/功能）的副作用可能会导致仿真器禁用优化！
- 这种情况，“坐着不如躺着”少唤醒最安全
- 就像前面例3.2条件的处理那样，尽量减少他们的执行，如下
    ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/3713f9a4-4184-4bad-beb6-8a9f46105bc2)
- iff的使用
   ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/2596e971-f1b1-4422-b336-5bada5aae63e)




#### 13.对于UVM平台中带约束的随机，尽量分解或简化
![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/5fc95231-b1ef-414f-95bc-850d6539da23)


#### 14.断言的序列和属性尽量避免使用局部变量能用单个对象，不要多new
![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/c9fc6d60-cc1f-4e26-8746-730353cb3628)



#### 15.覆盖率收集时，尽可能减少采样事件
- 上面第二段代码之所以比第一段快，是因为合并使用了相同事件的采样过程，更少的coverage采样事件可以减少仿真时间。
- 所以除此之外，尽量使用特定事件触发器而不是诸如系统时钟之类的通用事件来采样覆盖率、覆盖组共享共同表达式等手段也可以减少仿真时间
- ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/179b2805-657f-409b-92ce-7f903704363f)


#### 16.可以使用宏加快循环计算
- 对于如下循环代码，reverse()函数会在大量的数据点被掉用，每次调用reverse( ) 都需要创建可能影响缓存命中的堆栈帧，仿真速度会非常慢。
- 使用REVERSE宏，就会使仿真更快。当然宏过度使用会增加调试难度和内存消耗。
- eg
  ![image](https://github.com/bulaqi/IC-DV.github.io/assets/55919713/25a80c52-f6f9-4371-a03c-4a7bf91ba0e6)

   
### 2. 经验


### 3. 传送门
1.[01 TOP 仿真加速](https://github.com/bulaqi/IC-DV.github.io/blob/main/doc/01%20TOP%20%E4%BB%BF%E7%9C%9F%E5%8A%A0%E9%80%9F.md)
2.[验证仿真提速系列--SystemVerilog编码层面提速的若干策略](https://zhuanlan.zhihu.com/p/384492472)
